import {
  AI_EXAM_RESPONSE,
  AIResponseItemSchemaType,
  QuestionsAndEmbeddings,
  StudentProfileInterface,
} from "../types/interfaces";
import aiClient from "../aiProviders";
import dbClient from "../database";
import {
  generateTestBasedOnTopicUtils,
  generateTestForGivenTopicAndLevelAndNumber,
  generateTestsBasedOnStudentProfileAndTopics,
} from "../utils/ai/generateUtils";
import {
  AIResponseItemSchema,
  CategorizedResponseSchema,
} from "../utils/ai/zod";
import { QUESTION_LEVEL } from "../types/constants";
import { z } from "zod";

const MAX_LIMIT_ITERATIONS = 10;

export const storeQuestionInVectorDB = async (
  questionObject: AIResponseItemSchemaType,
  metaData: any
) => {
  const createEmbeddingResponse = await aiClient?.getEmbeddingsOfTexts(
    JSON.stringify(questionObject)
  );

  createEmbeddingResponse?.data?.forEach((e) => {
    dbClient?.storeEmbeddigs(e.embedding, metaData);
  });
  return createEmbeddingResponse;
};

export const generateTestsForTopics = async (topics: string) => {
  const prompt = generateTestBasedOnTopicUtils(topics);
  const responseFromAI: AI_EXAM_RESPONSE = await aiClient?.generateFromAi(
    prompt,
    CategorizedResponseSchema
  );
  if (responseFromAI) {
    // TODO: also have an archive service that stores the questions that are generated by AI
    Object.entries(responseFromAI).forEach(([key, value]) => {
      value.forEach(async (questionObject) => {
        await storeQuestionInVectorDB(questionObject, { topics, level: key });
      });
    });
  }
  return responseFromAI;
};

export const generateTestForStudentProfileAndTopic = async (
  topics: string[],
  studentProfile: StudentProfileInterface
) => {
  const prompt = generateTestsBasedOnStudentProfileAndTopics(
    topics,
    studentProfile
  );
  const responseFromAi = await aiClient?.generateFromAi(
    prompt,
    CategorizedResponseSchema
  );
  return responseFromAi;
};

export const generateLongTests = async (
  testId: string,
  topics: string[],
  difficulty: typeof QUESTION_LEVEL,
  count: number
) => {
  const batchSize = Number(process.env.MAX_BATCH_SIZE ?? 15);

  let questions: QuestionsAndEmbeddings = { text: [], embeddings: [] };
  let HARD_CHECK_TO_LIMIT_ITERATIONS = 0;

  while (count > 0) {
    const numberOfQuestions = count > batchSize ? batchSize : count;
    const prompt = generateTestForGivenTopicAndLevelAndNumber(
      topics,
      difficulty,
      numberOfQuestions
    );
    const responseFromAI: AIResponseItemSchemaType[] = await aiClient
      ?.generateFromAi(
        prompt,
        z.object({ questions: z.array(AIResponseItemSchema) })
      )
      .then((res) => res.questions);
    if (responseFromAI) {
      console.log("responseFromAI");
      const questionsToStore = await deduplicateAndStoreQuestions(
        responseFromAI,
        questions
      );
      questions.text.push(...questionsToStore.text);
      questions.embeddings.push(...questionsToStore.embeddings);
      count -= questionsToStore.text.length;
      // break;
      console.log("count", count, questions.text.length);
      HARD_CHECK_TO_LIMIT_ITERATIONS++;
      if (HARD_CHECK_TO_LIMIT_ITERATIONS > MAX_LIMIT_ITERATIONS) {
        break;
      }
    } else {
      throw new Error("Error in generating questions");
    }
  }
  questions.embeddings.forEach((embedding) => {
    dbClient?.storeEmbeddigs(embedding, { testId, topics });
  });
  // console.log(questions.text, "returning questions");
  return questions.text;
};

const deduplicateAndStoreQuestions = async (
  responseFromAI: AIResponseItemSchemaType[],
  alreadyGeneratedQuestions: QuestionsAndEmbeddings
) => {
  // console.log("Entering deduplicateAndStoreQuestions");
  const questionsToStore: QuestionsAndEmbeddings = { text: [], embeddings: [] };

  for (const questionObject of responseFromAI) {
    const embeddingForQuestion = await aiClient?.getEmbeddingsOfTexts(
      JSON.stringify(questionObject)
    );

    // console.log("embeddingForQuestion", embeddingForQuestion);

    if (embeddingForQuestion && alreadyGeneratedQuestions.embeddings.length) {
      let isUnique = true;

      for (const existingEmbedding of alreadyGeneratedQuestions.embeddings) {
        const similarityScore = aiClient?.compareTwoEmbeddings(
          embeddingForQuestion?.data[0].embedding,
          existingEmbedding
        );

        console.log(similarityScore);

        if (similarityScore && similarityScore >= 0.8) {
          isUnique = false;
          break;
        }
      }

      if (isUnique) {
        questionsToStore.text.push(questionObject);
        questionsToStore.embeddings.push(
          embeddingForQuestion.data[0].embedding
        );
      }
    } else if (
      alreadyGeneratedQuestions.embeddings.length === 0 &&
      embeddingForQuestion
    ) {
      // console.log("Adding first embedding");
      questionsToStore.text.push(questionObject);
      questionsToStore.embeddings.push(embeddingForQuestion.data[0].embedding);
    }
  }

  return questionsToStore;
};
